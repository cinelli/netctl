#! /bin/bash

. /home/cinelli/dev/netctl/src/lib/globals
#. /usr/lib/network/globals


usage() {
    cat << END
Usage: netctl {COMMAND} [PROFILE]
              [--help|--version]

Commands:
  list                 List available profiles
  store                Save which profiles are active
  restore              Load saved profiles
  stop-all             Stops all profiles
  start [PROFILE]      Start a profile
  stop [PROFILE]       Stop a profile
  restart [PROFILE]    Restart a profile
  switch-to [PROFILE]  Switch to a profile
  status [PROFILE]     Show runtime status of a profile
  enable [PROFILE]     Enable the systemd unit for a profile
  disable [PROFILE]    Disable the systemd unit for a profile
  reenable [PROFILE]   Reenable the systemd unit for a profile
END
}

#sd_escape() {
#    local IFS=''
#    # Prevent a recursion loop on backspaces
#    set -- "${@//\\/\\x5c}"
#    while [[ "$*" =~ [^[:alnum:].:_/\\] ]]; do
#        set -- "${@//$BASH_REMATCH/$(printf "\x%x" "$BASH_REMATCH")}"
#    done
#    printf "%s\n" "${@//\//-}"
#}

# Wrapper around systemctl to convert profile names to unit names
sd_call() {
    local command="$1"
    shift
    systemctl "$command" "$(printf "%s" "/"netctl@$@.service/"\n")"
}

list() {
    local indicators=( '*' ' ' )
    list_files "$profile_dir" | while read -r Profile; do
        sd_call "is-active --quiet" "$Profile" &> /dev/null
        # Make the return value boolean
        printf "%s %s\n" "${indicators[!! $?]}" "$Profile"
    done
}

store() {
    mkdir -p "$(dirname $state_file)"
    list_files "$profile_dir" | while read -r Profile; do
        if sd_call "is-active --quiet" "$Profile" &> /dev/null; then
            printf "%s\n" "$Profile"
        fi
    done > "$state_file"
}

restore() {
    if [[ ! -r $state_file ]]; then
        report error "Could not read state file $state_file"
    elif [[ ! -s $state_file ]]; then
        report debug "No profiles to restore in state file $state_file"
    else
        mapfile -t Profiles < "$state_file"
        do_debug sd_call start "${Profiles[@]}"
    fi
}

stop_all() {
    # We cannot pipe to mapfile, as the end of a pipe is inside a subshell
    mapfile -t Profiles < <(list_files "$profile_dir")
    [[ $Profiles ]] && do_debug sd_call stop "${Profiles[@]}" 2> >(grep -Fv "not loaded" >&2)
}

switch_to() {
    cd "$profile_dir"
    [[ -r $1 ]] || report error "Profile $1 does not exist or is not readable"
    # We assume interface names are not quoted
    # Using read removes leading whitespace
    read InterfaceLine < <(grep -om1 "^[[:space:]]*Interface=[[:alnum:]:._-]\+" "$1")
    if [[ -z $InterfaceLine ]]; then
        report error "Profile $1 does not specify an interface"
    fi
    mapfile -t AllProfiles < <(list_files "$profile_dir")
    mapfile -t Profiles < <(grep -Fl "$InterfaceLine" "${AllProfiles[@]}")
    [[ $Profiles ]] && do_debug sd_call stop "${Profiles[@]}" 2> >(grep -Fv "not loaded" >&2)
    do_debug sd_call start "$1"
}

unit_enable() {
    local unit="@systemdsystemconfdir@/netctl@${1}.service"
    [[ -e $unit ]] && report error "A unit file for profile $1 already exists" && return 1
    load_profile "$1"
    printf "%q" ".include @systemdsystemunitdir@/netctl@${1}.service\n" > "$unit"
    printf "%s" "[Unit]" >> "$unit"
    [[ -n $Description ]] && printf "%s\n" "Description=$Description" >> "$unit"
    [[ -v BindsToInterfaces ]] || BindsToInterfaces="$Interface"
    if (( ${#BindsToInterfaces[@]} )); then
        : ${InterfaceRoot=sys/subsystem/net/devices/}
        printf "BindsTo=${InterfaceRoot}${BindsToInterfaces[@]}.device\n" >> "$unit"
        printf "After=${InterfaceRoot}${BindsToInterfaces[@]}.device\n" >> "$unit"
    fi
    if (( ${#After[@]} )); then
        printf "%s" "After=netctl@${After[@]}.service\n" >> "$unit"
    fi
    mkdir -p "@systemdsystemconfdir@/multi-user.target.wants"
#   echo "ln -s '$unit' '${unit/system\//system/multi-user.target.wants/}'"
    printf "%s" "ln -s '$unit' '${unit/system\//system/multi-user.target.wants/}'\n"
    ln -s "$unit" "${unit/system\//system/multi-user.target.wants/}"
    systemctl daemon-reload
}
cd /
unit_disable() {
    local unit="@systemdsystemconfdir@/netctl@${1}.service"
    if sd_call "is-enabled --quiet" "$1" &> /dev/null; then
        sd_call disable "$1"
    fi
    if [[ ! -f $unit ]]; then
        report error "No regular unit file found for profile $1"
        return 1
    fi
    do_debug rm "$unit"
    systemctl daemon-reload
}


case "$#" in
  1)
    case "$1" in
      --version)
          report notice "netctl version $netctl_version"
          ;;
      --help)
          usage
          ;;
      list)
          list
          ;;
      store|restore)
          ensure_root "$(basename "$0")"
          "$1"
          ;;
      stop-all)
          stop_all
          ;;
      *)
          report error "$(usage)"
          ;;
  esac
  ;;
  2)
    case "$1" in
      start|stop|restart|status)
        sd_call "$1" "$2";;
      switch-to)
        ensure_root "$(basename "$0")"
        switch_to "$2";;
      enable|disable)
        ensure_root "$(basename "$0")"
        "unit_$1" "$2";;
      reenable)
        ensure_root "$(basename "$0")"
        unit_disable "$2"
        unit_enable "$2";;
      *)
        report error "$(usage)";;
    esac;;
  *)
    report error "$(usage)";;
esac


# vim: ft=sh ts=4 et sw=4:
